ama ben zaten find_path içinde static char *find_path(char *cmd)
{
	char **paths;
	char *tmp;
	char *candidate;
	char *full_path;
	int i = 0;
	// Eğer komut bir path içeriyorsa doğrudan kontrol et
	if (ft_strchr(cmd, '/'))
	{
		if (access(cmd, X_OK) == 0)
			return ft_strdup(cmd);
		else
			return NULL;
	}// PATH ortam değişkenini al
	tmp = ft_path();
	if (!tmp)
		return NULL;
	paths = ft_split(tmp, ':');
	free(tmp);
	while (paths[i])
	{
		candidate = ft_strjoin(paths[i], "/");
		full_path = ft_strjoin(candidate, cmd);
		free(candidate);
		if (access(full_path, X_OK) == 0)
			return full_path;// paths dizisini free etmeyi unutma (ileride)
		free(full_path);
		i++;
	}// paths dizisini burada da free etmeyi unutma (ileride)
	return NULL;
} şeklinde kontorllerimi yapıyorum neden bir daha exec_chil içine char *path = NULL;

if (ft_strchr(cmd->av[0], '/'))
{
	if (access(cmd->av[0], F_OK) != 0)
		error(cmd->av[0], ": No such file or directory\n", 127);
	else if (access(cmd->av[0], X_OK) != 0)
		error(cmd->av[0], ": Permission denied\n", 126);
	else
	{
		struct stat st;
		if (stat(cmd->av[0], &st) == 0 && S_ISDIR(st.st_mode))
			error(cmd->av[0], ": Is a directory\n", 126);
		path = ft_strdup(cmd->av[0]);
	}
}
else
{
	path = find_path(cmd->av[0]);
	if (!path)
		error(cmd->av[0], ": command not found\n", 127);
}
 şeklinde bir kontrol yapayım ki fazladan bir daha kontrol etmiş olmuyor muyum nasıl olması laızm bunu